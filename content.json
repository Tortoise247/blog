{"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2024/04/28/hello-world/"},{"title":"C#-API-firststep","text":"C# (Asp.NET Core)でAPIを作成する C# (Asp.NET Core)でAPIを作成する 1. はじめに 2. プロジェクトの作成 3. プロジェクトの構成 4. プロジェクトの実行 5. プロジェクトのデバッグ 6. プロジェクトのビルド 7. プロジェクトのデプロイ 8. おわりに 1. はじめにこの記事では、C# (Asp.NET Core)でAPIを作成する方法について説明します。 参考URLhttps://learn.microsoft.com/ja-jp/aspnet/core/getting-started/?view=aspnetcore-8.0&amp;tabs=windows 2. プロジェクトの作成まず、以下のコマンドを実行して、新しいプロジェクトを作成します。 1$ dotnet new 3. プロジェクトの構成プロジェクトの構成は以下のようになります。 1234567MyApi/├── Controllers/│ └── ValuesController.cs├── Models/│ └── Value.cs├── MyApi.csproj└── Program.cs 4. プロジェクトの実行プロジェクトを実行するには、以下のコマンドを実行します。 1$ dotnet run 5. プロジェクトのデバッグプロジェクトをデバッグするには、以下のコマンドを実行します。 1$ dotnet watch run 6. プロジェクトのビルドプロジェクトをビルドするには、以下のコマンドを実行します。 1$ dotnet build 7. プロジェクトのデプロイプロジェクトをデプロイするには、以下のコマンドを実行します。 1$ dotnet publish 8. おわりに以上で、C# (Asp.NET Core)でAPIを作成する方法について説明しました。","link":"/2024/04/29/C-API-firststep/"},{"title":"dotnetCore_on_Linux_1","text":"Linux上で.NET Coreを使う1. .NET Core SDKのインストール公式サイト 1sudo dnf install dotnet-sdk-8.0 2. プロジェクトの作成1dotnet new console -o myApp 3. プロジェクトのビルド123cd myAppdotnet build 4. プロジェクトの実行1dotnet run “Hello, World!”と表示されれば成功です。","link":"/2024/05/12/dotnetCore-on-Linux-1/"},{"title":"RockyLinux9にSSHをインストールする","text":"RockyLinux9にSSHをインストールする1. SSHのインストール1sudo dnf install openssh-server 2. SSHの起動1sudo systemctl start sshd 3. SSHの自動起動1sudo systemctl enable sshd 4. SSHの確認1sudo systemctl status sshd 5. SSHの設定1sudo vi /etc/ssh/sshd_config パスワード認証を有効にする1PasswordAuthentication yes 6. SSHの再起動1sudo systemctl restart sshd 以上でSSHのインストールと設定が完了しました。","link":"/2024/05/19/RockyLinux9%E3%81%ABSSH%E3%82%92%E3%82%A4%E3%83%B3%E3%82%B9%E3%83%88%E3%83%BC%E3%83%AB%E3%81%99%E3%82%8B/"},{"title":"SQLServerで大量のReplaceを実行する","text":"はじめにSQLServer上のテーブルに対して大量のReplaceを実行する必要があったので、その方法を調査しました。 テストデータ作成以下のようなテストデータを作成します。 12345678910111213141516171819202122CREATE TABLE SampleTable ( ID INT PRIMARY KEY IDENTITY(1,1), 名前 NVARCHAR(50), 年齢 INT, 性別 NVARCHAR(10), 住所 NVARCHAR(100), 電話番号 NVARCHAR(20), メールアドレス NVARCHAR(100), 登録日 DATE, 更新日 DATE, 会社名 NVARCHAR(100), 部署 NVARCHAR(50), 役職 NVARCHAR(50), 給与 DECIMAL(10, 2), 契約期間 NVARCHAR(50), メモ NVARCHAR(500), プロジェクト NVARCHAR(100), ステータス NVARCHAR(20), コメント NVARCHAR(500), 承認者 NVARCHAR(50), 承認日 DATE); テストデータ挿入以下のようなテストデータを挿入します。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950WITH Numbers AS ( SELECT TOP (1000000) ROW_NUMBER() OVER (ORDER BY (SELECT NULL)) AS n FROM sys.all_columns a CROSS JOIN sys.all_columns b),RandomChars AS ( SELECT ROW_NUMBER() OVER (ORDER BY (SELECT NULL)) AS id, NCHAR(0x3040 + ABS(CHECKSUM(NEWID())) % 85) AS Char1, NCHAR(0x30A0 + ABS(CHECKSUM(NEWID())) % 90) AS Char2, NCHAR(0xD83C) + NCHAR(0xDF00 + ABS(CHECKSUM(NEWID())) % 0x100) AS Char3, NCHAR(0x4E00 + ABS(CHECKSUM(NEWID())) % 20902) AS Char4 FROM sys.all_columns a CROSS JOIN sys.all_columns b)INSERT INTO SampleTable (名前, 年齢, 性別, 住所, 電話番号, メールアドレス, 登録日, 更新日, 会社名, 部署, 役職, 給与, 契約期間, メモ, プロジェクト, ステータス, コメント, 承認者, 承認日)SELECT TOP (1000000) (SELECT TOP (2 + ABS(CHECKSUM(NEWID())) % 9) RC.Char1 + RC.Char2 + RC.Char3 + RC.Char4 FROM RandomChars AS RC WHERE RC.id = N.n ORDER BY NEWID() FOR XML PATH(''), TYPE).value('.', 'NVARCHAR(MAX)') AS 名前, ABS(CHECKSUM(NEWID())) % 100 AS 年齢, CASE ABS(CHECKSUM(NEWID())) % 2 WHEN 0 THEN N'男性' ELSE N'女性' END AS 性別, N'ランダム住所' + CAST(n AS NVARCHAR(10)) AS 住所, N'090-' + RIGHT('0000' + CAST(ABS(CHECKSUM(NEWID())) % 10000 AS NVARCHAR(4)), 4) + '-' + RIGHT('0000' + CAST(ABS(CHECKSUM(NEWID())) % 10000 AS NVARCHAR(4)), 4) AS 電話番号, N'random' + CAST(n AS NVARCHAR(10)) + N'@example.com' AS メールアドレス, DATEADD(DAY, ABS(CHECKSUM(NEWID())) % 3650, '2000-01-01') AS 登録日, DATEADD(DAY, ABS(CHECKSUM(NEWID())) % 3650, '2010-01-01') AS 更新日, N'会社名' + CAST(n AS NVARCHAR(10)) AS 会社名, N'部署' + CAST(n AS NVARCHAR(10)) AS 部署, N'役職' + CAST(n AS NVARCHAR(10)) AS 役職, CAST(ABS(CHECKSUM(NEWID())) % 100000 AS DECIMAL(10, 2)) AS 給与, N'契約期間' + CAST(n AS NVARCHAR(10)) AS 契約期間, N'メモ' + CAST(n AS NVARCHAR(10)) AS メモ, N'プロジェクト' + CAST(n AS NVARCHAR(10)) AS プロジェクト, CASE ABS(CHECKSUM(NEWID())) % 3 WHEN 0 THEN N'進行中' WHEN 1 THEN N'完了' ELSE N'保留' END AS ステータス, N'コメント' + CAST(n AS NVARCHAR(10)) AS コメント, N'承認者' + CAST(n AS NVARCHAR(10)) AS 承認者, DATEADD(DAY, ABS(CHECKSUM(NEWID())) % 3650, '2020-01-01') AS 承認日FROM Numbers AS NCROSS APPLY ( SELECT TOP (2 + ABS(CHECKSUM(NEWID())) % 9) NCHAR(0x3040 + ABS(CHECKSUM(NEWID())) % 85) + NCHAR(0x30A0 + ABS(CHECKSUM(NEWID())) % 90) + NCHAR(0xD83C) + NCHAR(0xDF00 + ABS(CHECKSUM(NEWID())) % 0x100) + NCHAR(0x4E00 + ABS(CHECKSUM(NEWID())) % 20902) as x1 FROM RandomChars) AS NameXML(x1);**** 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061DECLARE @RowCount INT = 1;DECLARE @TotalRows INT = 100000;DECLARE @BatchSize INT = 2000;WHILE @RowCount &lt;= @TotalRowsBEGIN WITH Numbers AS ( SELECT ROW_NUMBER() OVER (ORDER BY (SELECT NULL)) AS n FROM sys.all_columns a CROSS JOIN sys.all_columns b ), RandomChars AS ( SELECT ROW_NUMBER() OVER (ORDER BY (SELECT NULL)) AS id, NCHAR(0x3040 + ABS(CHECKSUM(NEWID())) % 85) AS Char1, NCHAR(0x30A0 + ABS(CHECKSUM(NEWID())) % 90) AS Char2, NCHAR(0xD83C) + NCHAR(0xDF00 + ABS(CHECKSUM(NEWID())) % 0x100) AS Char3, NCHAR(0x4E00 + ABS(CHECKSUM(NEWID())) % 20902) AS Char4 FROM sys.all_columns a CROSS JOIN sys.all_columns b ), CTE AS ( SELECT N.n, (SELECT TOP (2 + ABS(CHECKSUM(NEWID())) % 9) RC.Char1 + RC.Char2 + RC.Char3 + RC.Char4 FROM RandomChars AS RC WHERE RC.id = N.n ORDER BY NEWID() FOR XML PATH(''), TYPE).value('.', 'NVARCHAR(MAX)') AS 名前, ABS(CHECKSUM(NEWID())) % 100 AS 年齢, CASE ABS(CHECKSUM(NEWID())) % 2 WHEN 0 THEN N'男性' ELSE N'女性' END AS 性別, N'ランダム住所' + CAST(n AS NVARCHAR(10)) AS 住所, N'090-' + RIGHT('0000' + CAST(ABS(CHECKSUM(NEWID())) % 10000 AS NVARCHAR(4)), 4) + '-' + RIGHT('0000' + CAST(ABS(CHECKSUM(NEWID())) % 10000 AS NVARCHAR(4)), 4) AS 電話番号, N'random' + CAST(n AS NVARCHAR(10)) + N'@example.com' AS メールアドレス, DATEADD(DAY, ABS(CHECKSUM(NEWID())) % 3650, '2000-01-01') AS 登録日, DATEADD(DAY, ABS(CHECKSUM(NEWID())) % 3650, '2010-01-01') AS 更新日, N'会社名' + CAST(n AS NVARCHAR(10)) AS 会社名, N'部署' + CAST(n AS NVARCHAR(10)) AS 部署, N'役職' + CAST(n AS NVARCHAR(10)) AS 役職, CAST(ABS(CHECKSUM(NEWID())) % 100000 AS DECIMAL(10, 2)) AS 給与, N'契約期間' + CAST(n AS NVARCHAR(10)) AS 契約期間, N'メモ' + CAST(n AS NVARCHAR(10)) AS メモ, N'プロジェクト' + CAST(n AS NVARCHAR(10)) AS プロジェクト, CASE ABS(CHECKSUM(NEWID())) % 3 WHEN 0 THEN N'進行中' WHEN 1 THEN N'完了' ELSE N'保留' END AS ステータス, N'コメント' + CAST(n AS NVARCHAR(10)) AS コメント, N'承認者' + CAST(n AS NVARCHAR(10)) AS 承認者, DATEADD(DAY, ABS(CHECKSUM(NEWID())) % 3650, '2020-01-01') AS 承認日, ROW_NUMBER() OVER (ORDER BY N.n) AS RowNumber FROM Numbers AS N ) INSERT INTO SampleTable (名前, 年齢, 性別, 住所, 電話番号, メールアドレス, 登録日, 更新日, 会社名, 部署, 役職, 給与, 契約期間, メモ, プロジェクト, ステータス, コメント, 承認者, 承認日) SELECT 名前, 年齢, 性別, 住所, 電話番号, メールアドレス, 登録日, 更新日, 会社名, 部署, 役職, 給与, 契約期間, メモ, プロジェクト, ステータス, コメント, 承認者, 承認日 FROM CTE WHERE RowNumber BETWEEN @RowCount AND @RowCount + @BatchSize - 1; SET @RowCount += @BatchSize; PRINT 'Inserted ' + CAST(@RowCount - 1 AS NVARCHAR(10)) + ' rows';END; Replace実行以下のようなReplaceを実行します。 123456789101112131415161718192021222324252627282930313233DECLARE @RowCount INT = 1;DECLARE @TotalRows INT = (SELECT COUNT(*) FROM SampleTable);DECLARE @BatchSize INT = 2000;WHILE @RowCount &lt;= @TotalRowsBEGIN BEGIN TRAN; WITH CTE AS ( SELECT *, ROW_NUMBER() OVER (ORDER BY (SELECT NULL)) AS RowNumber FROM SampleTable ) UPDATE CTE SET 名前 = REPLACE(名前, 'あ', '') WHERE 名前 LIKE '%あ%' AND RowNumber BETWEEN @RowCount AND @RowCount + @BatchSize - 1; UPDATE CTE SET 名前 = REPLACE(名前, 'い', '') WHERE 名前 LIKE '%い%' AND RowNumber BETWEEN @RowCount AND @RowCount + @BatchSize - 1; UPDATE CTE SET 名前 = REPLACE(名前, 'う', '') WHERE 名前 LIKE '%う%' AND RowNumber BETWEEN @RowCount AND @RowCount + @BatchSize - 1; ROLLBACK; SET @RowCount += @BatchSize;END;","link":"/2024/05/29/SQLServer%E3%81%A7%E5%A4%A7%E9%87%8F%E3%81%AEReplace%E3%82%92%E5%AE%9F%E8%A1%8C%E3%81%99%E3%82%8B/"},{"title":"Keycloak + .NET で始める認証・認可","text":"その１：Keycloakの概要と導入方法Keycloakの基本的な使い方や、Keycloakを使った.NETアプリケーションの認証・認可の仕組みについて説明します。複数回の記事に分けで、すこしずつ進めていきたいと思います。 まずは、Keycloakの概要とDockerでの導入方法について説明します。 Keycloakとは？ KeycloakはWebアプリケーションおよびRESTfulなWebサービスのためのシングル・サインオン・ソリューションです。Keycloakの目的はセキュリティーをシンプルに実現し、アプリケーション開発者が組織内にデプロイしたアプリケーションやサービスを保護することです。開発者が通常自分達自身で書かないといけないセキュリティー機能はすぐに提供され、組織内の個々の要件に合わせて簡単に調整することができます。Keycloakは、ログイン、登録、システム管理、アカウント管理のための、カスタマイズ可能なユーザー・インターフェイスを提供しています。Keycloakは、既存のLDAPやActive Directoryサーバーへ接続し、統合プラットフォームとして利用することもできます。また、FacebookやGoogleのようなサードパーティーのアイデンティティー・プロバイダーに対して、認証を委譲することも可能です。 引用元：公式ガイド（日本語訳） Keycloakの導入方法まずは、お手軽にDockerを使ってKeycloakを導入してみます。以下は、Dockerを使ったKeycloakの基本的なセットアップ手順です： DockerでKeycloakを起動1docker run -d -p 8080:8080 -e KEYCLOAK_ADMIN=admin -e KEYCLOAK_ADMIN_PASSWORD=admin quay.io/keycloak/keycloak:latest start-dev これだけで、Keycloakが起動します。 Docker Desktopで確認 ログインブラウザでhttp://localhost:8080にアクセスし、Keycloakの管理画面にログインします。 ユーザ名、パスワードは、上記のKEYCLOAK_ADMINとKEYCLOAK_ADMIN_PASSWORDに指定した値でログインできます。","link":"/2024/10/31/Keycloak-NET-%E3%81%A7%E5%A7%8B%E3%82%81%E3%82%8B%E8%AA%8D%E8%A8%BC%E3%83%BB%E8%AA%8D%E5%8F%AF/"},{"title":"Keycloak + .NET で始める認証・認可","text":"最低限の初期設定とトークン取得Keycloakの初期設定まずは、Keycloakの初期設定を行います。※起動方法は前回の記事参照 ブラウザでhttp://localhost:8080にアクセスし、Keycloakの管理画面にログインします。 ユーザ名、パスワードは、上記のKEYCLOAK_ADMINとKEYCLOAK_ADMIN_PASSWORDに指定した値でログインできます。 ) ログイン後、Masterレルムが選択されていることを確認します。 Add realmをクリックし、新しいレルムを作成します。 レルム名を入力し、Createをクリックします。 ここでは、MyRealmという名前で作成します。 レルムが作成されたら、MyRealmを選択します。 Clientsをクリックし、Createをクリックします。 Client IDにmy-clientを入力し、Saveをクリックします。 これで、クライアントが作成されました。 my-clientを選択し、Settingsタブをクリックします。 Access Typeをconfidentialに変更し、Saveをクリックします。 これで、クライアントの設定が完了しました。 トークンエンドポイントの確認Keycloakのトークンエンドポイントを確認します。 MyRealmを選択します。 Clientsをクリックし、my-clientを選択します。 Credentialsタブをクリックし、Client Secretの値をコピーします。 この値は、後でトークンを取得する際に必要です。 Endpointsタブをクリックし、Token Endpointの値をコピーします。 Token Endpointの値をメモ帳などに保存しておきます。 この値は、後でトークンを取得する際に必要です。 トークンの取得.NETアプリケーションでKeyclaokを利用することが目的ですが、いったん、Powershellを使ってトークンを取得してみます。 123456789101112$realm = &quot;MyRealm&quot;$client_id = &quot;my-client&quot;$client_secret$token_endpoint = &quot;http://localhost:8080/auth/realms/$realm/protocol/openid-connect/token&quot;$token = Invoke-RestMethod -Method Post -Uri $token_endpoint -Body @{ client_id = $client_id client_secret = $client_secret grant_type = &quot;client_credentials&quot;} -ContentType &quot;application/x-www-form-urlencoded&quot;$token $client_secretには、my-clientのCredentialsタブで設定したClient Secretの値を入力します。 これで、トークンが取得できました。 トークンの確認取得したトークンをデコードして中身を確認してみます。 1$token.access_token | ConvertFrom-Json | Format-List トークンの中身が表示されれば、トークンの取得は成功です。 トークンの内容は、jwt.ioなどのサイトで確調してみると、より詳細な情報が確認できます。","link":"/2024/10/31/Keycloak-NET-%E3%81%A7%E5%A7%8B%E3%82%81%E3%82%8B%E8%AA%8D%E8%A8%BC%E3%83%BB%E8%AA%8D%E5%8F%AF-%EF%BC%92/"}],"tags":[{"name":"C#","slug":"C","link":"/tags/C/"},{"name":"API","slug":"API","link":"/tags/API/"}],"categories":[],"pages":[]}